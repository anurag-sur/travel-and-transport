<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>AR Models</title>
<script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
<script src="https://raw.githack.com/AR-js-org/AR.js/3.3.2/aframe/build/aframe-ar.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
*{ box-sizing:border-box; }

body{
  margin:0;
  overflow:hidden;
  font-family:'Inter',sans-serif;
  background:#0b0b0c;
  color:white;
}

/* ---------- Top Bar ---------- */
#topBar{
  position:absolute;
  top:0;
  left:0;
  right:0;
  padding:12px 20px;
  background:linear-gradient(180deg, rgba(0,0,0,.6) 0%, transparent 100%);
  z-index:5;
  display:flex;
  justify-content:flex-start;
  align-items:center;
}

#logo{
  font-size:18px;
  font-weight:700;
  letter-spacing:-0.5px;
}

/* ---------- Info Card ---------- */
#infoCard{
  position:absolute;
  top:60px;
  left:50%;
  transform:translateX(-50%);
  width:90%;
  max-width:320px;
  padding:12px 16px;
  background:rgba(20,20,22,.92);
  backdrop-filter:blur(20px);
  border-radius:14px;
  border:1px solid rgba(255,255,255,.08);
  z-index:5;
  box-shadow:0 8px 24px rgba(0,0,0,.3);
  text-align:center;
}

#foodName{
  font-size:18px;
  font-weight:700;
  margin-bottom:4px;
}

#foodPrice{
  font-size:18px;
  font-weight:700;
  color:#4CAF50;
  margin-bottom:6px;
}

/* ---------- Main Controls (only navigation) ---------- */
#controls{
  position:absolute;
  bottom:0;
  left:0;
  right:0;
  padding:20px;
  background:linear-gradient(0deg, rgba(0,0,0,.7) 0%, transparent 100%);
  z-index:5;
  display:flex;
  justify-content:center;
}

#navButtons{
  display:flex;
  gap:12px;
  margin-bottom:16px;
  justify-content:center;
}

.nav-btn{
  width:56px;
  height:56px;
  background:rgba(30,30,32,.9);
  border:1px solid rgba(255,255,255,.12);
  color:white;
  border-radius:50%;
  font-size:24px;
  cursor:pointer;
  transition:all .15s;
  display:flex;
  align-items:center;
  justify-content:center;
  backdrop-filter:blur(10px);
}

.nav-btn:active{
  transform:scale(.94);
  background:rgba(50,50,55,.95);
}

/* ---------- Loading ---------- */
#loading{
  position:absolute;
  inset:0;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  background:#0b0b0c;
  z-index:102;
  gap:16px;
}

#loadingText{
  font-size:18px;
  font-weight:600;
}

#loadingBar{
  width:200px;
  height:4px;
  background:rgba(255,255,255,.1);
  border-radius:2px;
  overflow:hidden;
}

#loadingProgress{
  height:100%;
  background:linear-gradient(90deg, #1f7aff, #0066ff);
  width:0%;
  transition:width .3s;
}

/* ---------- Toast ---------- */
#toast{
  position:absolute;
  top:90px;
  left:50%;
  transform:translateX(-50%);
  background:rgba(31,122,255,.95);
  backdrop-filter:blur(20px);
  padding:12px 18px;
  border-radius:12px;
  font-size:14px;
  font-weight:600;
  opacity:0;
  transition:opacity .3s;
  z-index:101;
  box-shadow:0 4px 20px rgba(31,122,255,.4);
}

a-scene { pointer-events: none; }

/* Allow UI elements to receive pointer events */
#topBar,
#infoCard,
#toast,
#controls,
.nav-btn {
  pointer-events: auto;
}
</style>
</head>

<body>

<!-- Top Bar -->
<div id="topBar">
  <div id="logo">ðŸš— TransportAR</div>
</div>

<!-- Info Card -->
<div id="infoCard">
  <div id="foodName"></div>
  <div id="foodPrice"></div>
</div>

<div id="toast"></div>
<div id="loading">
  <div id="loadingText">Loading modelsâ€¦</div>
  <div id="loadingBar">
    <div id="loadingProgress"></div>
  </div>
</div>

<!-- Main Controls (only navigation) -->
<div id="controls">
  <div id="navButtons">
    <button class="nav-btn" id="left">â€¹</button>
    <button class="nav-btn" id="right">â€º</button>
  </div>
</div>

<a-scene embedded vr-mode-ui="enabled:false"
         arjs="sourceType:webcam; debugUIEnabled:false;">
  <a-entity light="type:ambient;intensity:0.8"></a-entity>
  <a-entity light="type:directional;intensity:0.4" position="1 2 1"></a-entity>
  <a-entity camera></a-entity>
  <a-entity id="holder" position="0 0 -4"></a-entity>
</a-scene>

<script>
const THREE = AFRAME ? AFRAME.THREE : window.THREE;

const foods=[
 {model:"models/bike/scene.gltf",name:"Bike",price:149,scale:.4,category:"western",views:1250,rating:4.5,orders:342},
 {model:"models/bus/scene.gltf",name:"Bus",price:299,scale:2,category:"western",views:2100,rating:4.8,orders:521},
 {model:"models/car/scene.gltf",name:"Car",price:99,scale:.5,category:"western",views:890,rating:4.2,orders:267},
 {model:"models/cruise_ship/scene.gltf",name:"Cruise ship",price:129,scale:6,category:"healthy",views:456,rating:4.3,orders:89},
 {model:"models/helicopter/scene.gltf",name:"Helicopter",price:89,scale:6,category:"indian",views:1567,rating:4.7,orders:423},
 {model:"models/metro/scene.gltf",name:"Metro",price:49,scale:6,category:"western",views:678,rating:4.1,orders:198},
 {model:"models/plane/scene.gltf",name:"Plane",price:79,scale:6,category:"indian",views:1123,rating:4.6,orders:312},
 {model:"models/submarine/scene.gltf",name:"Submarine",price:89,scale:.01,category:"healthy",views:345,rating:4.0,orders:76},
];

const holder=document.getElementById("holder");
const infoCard=document.getElementById("infoCard");
const foodName=document.getElementById("foodName");
const foodPrice=document.getElementById("foodPrice");
const loading=document.getElementById("loading");
const loadingText=document.getElementById("loadingText");
const loadingProgress=document.getElementById("loadingProgress");
const toast=document.getElementById("toast");

let index=0;
let autoRotate=true;
const models=[];
let loadedCount=0;

/* ---------- Helpers ---------- */
function showToast(t){
 toast.textContent=t;
 toast.style.opacity=1;
 clearTimeout(showToast._hideTimer);
 showToast._hideTimer = setTimeout(()=>toast.style.opacity=0,1800);
}

/* ---------- Preload all models + center & normalize scale ---------- */
foods.forEach((food,i)=>{
 const m=document.createElement("a-entity");
 // set gltf model attribute - A-Frame will load it asynchronously
 m.setAttribute("gltf-model",food.model);

 // keep entities hidden until explicitly shown
 m.object3D.visible=false;

 // store original requested scale
 m.userData.requestedScale = (typeof food.scale === 'number' && isFinite(food.scale)) ? food.scale : 1;

 holder.appendChild(m);
 models.push(m);

 // model-loaded event provides the loaded model via evt.detail.model
 m.addEventListener("model-loaded", (evt) => {
  try {
    const loadedModel = evt && evt.detail && evt.detail.model ? evt.detail.model : m.object3D;
    const Box3 = THREE.Box3;
    const Vector3 = THREE.Vector3;

    // compute bbox from the actual loaded model
    const bbox = new Box3().setFromObject(loadedModel);
    const size = bbox.getSize(new Vector3());
    const center = bbox.getCenter(new Vector3());

    // Recenter entity so the model is centered on X,Z and rests on Y=0
    // We apply this translation to the entity so that child geometry positions become correct
    m.object3D.position.x -= center.x || 0;
    m.object3D.position.z -= center.z || 0;
    m.object3D.position.y -= (bbox.min && isFinite(bbox.min.y)) ? bbox.min.y : 0;

    // Normalize scale to keep very large or very small models reasonable
    const targetHeight = 1.6; // meters
    let currentScale = (m.userData.requestedScale && m.userData.requestedScale > 0) ? m.userData.requestedScale : 1;
    const modelHeight = (size && isFinite(size.y)) ? size.y * currentScale : 0;

    if (!modelHeight || isNaN(modelHeight) || modelHeight === 0) {
      // fallback: if bbox couldn't be computed, keep requested scale
      m.userData.normalizedScale = currentScale;
      m.object3D.scale.set(currentScale, currentScale, currentScale);
    } else if (modelHeight > targetHeight) {
      const scaleFactor = targetHeight / modelHeight;
      currentScale = currentScale * scaleFactor;
      m.object3D.scale.set(currentScale, currentScale, currentScale);
      m.userData.normalizedScale = currentScale;
    } else {
      m.userData.normalizedScale = currentScale;
      m.object3D.scale.set(currentScale, currentScale, currentScale);
    }

    // enable shadows on meshes inside the loaded model (optional)
    loadedModel.traverse(node => {
      if (node.isMesh) {
        node.castShadow = true;
        node.receiveShadow = true;
      }
    });

    // Update loading UI
    loadedCount++;
    const progress=(loadedCount/foods.length)*100;
    loadingProgress.style.width=progress+"%";
    loadingText.textContent=`Loading modelsâ€¦ ${loadedCount}/${foods.length}`;

    // If everything finished (including any errors handled by model-error),
    // hide the loading overlay and display the first model
    if(loadedCount===foods.length){
     setTimeout(()=>{
      loading.style.display="none";
      showModel(0);
      showToast("Models loaded");
     },300);
    }
  } catch (err) {
    console.error("Error during model-loaded handling for", food.model, err);
    // ensure we don't block the loading UI
    loadedCount++;
    loadingProgress.style.width = ((loadedCount/foods.length)*100) + "%";
    loadingText.textContent=`Loading modelsâ€¦ ${loadedCount}/${foods.length}`;
    if(loadedCount===foods.length){
     setTimeout(()=>{
      loading.style.display="none";
      showModel(0);
      showToast("Models loaded (with warnings)");
     },300);
    }
  }
 });

 // Handle model load errors so the UI doesn't wait forever
 m.addEventListener("model-error", (evt) => {
   console.error(`Model failed to load: ${food.model}`, evt);
   showToast(`Failed to load ${food.name}`);
   // mark as "loaded" so progress continues
   loadedCount++;
   const progress=(loadedCount/foods.length)*100;
   loadingProgress.style.width=progress+"%";
   loadingText.textContent=`Loading modelsâ€¦ ${loadedCount}/${foods.length}`;
   // still set a normalizedScale fallback so showModel won't blow up
   if (!m.userData.normalizedScale) {
     m.userData.normalizedScale = m.userData.requestedScale || 1;
     m.object3D.scale.set(m.userData.normalizedScale, m.userData.normalizedScale, m.userData.normalizedScale);
   }
   if(loadedCount===foods.length){
     setTimeout(()=>{
      loading.style.display="none";
      showModel(0);
      showToast("Models loaded (some failed)");
     },300);
   }
 });

}); // end foods.forEach

/* ---------- Show model ---------- */
function showModel(i){
 // hide all
 models.forEach((m,idx)=>{
   if (m && m.object3D) m.object3D.visible = false;
 });

 const m = models[i];
 if (!m) return;

 // apply normalized scale if available, else use requested scale
 const normalized = (m && m.userData && m.userData.normalizedScale) ? m.userData.normalizedScale : (m.userData.requestedScale || 1);
 m.object3D.scale.set(normalized, normalized, normalized);

 // reset rotation
 m.object3D.rotation.set(0,0,0);
 // make visible
 m.object3D.visible = true;

 foodName.textContent = foods[i].name;
 foodPrice.textContent = `â‚¹${foods[i].price}`;
}

/* ---------- UI: only navigation ---------- */
document.getElementById("left").onclick=()=>{
  index=(index+foods.length-1)%foods.length;
  showModel(index);
};
document.getElementById("right").onclick=()=>{
  index=(index+1)%foods.length;
  showModel(index);
};
</script>
</body>
</html>
